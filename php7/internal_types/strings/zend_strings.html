
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Strings management: zend_string &#8212; PHP Internals Book</title>
    <link rel="stylesheet" href="../../../_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/style.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="smart_str API" href="smart_str.html" />
    <link rel="prev" title="Strings management" href="../strings.html" /> 
  </head>
  <body>
      <div class="header" role="banner"><h1 class="heading"><a href="../../../index.html">
          <span>PHP Internals Book</span></a></h1>
        <h2 class="heading"><span>Strings management: zend_string</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="../strings.html">Strings management</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../../../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="smart_str.html">smart_str API</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="strings-management-zend-string">
<h1>Strings management: zend_string<a class="headerlink" href="#strings-management-zend-string" title="Permalink to this headline">¶</a></h1>
<p>Any program needs to manage strings. Here, we’ll detail a custom solution that fits PHP needs : <code class="docutils literal"><span class="pre">zend_string</span></code>.
Every time PHP needs to work with a string, a <code class="docutils literal"><span class="pre">zend_string</span></code> structure will be used. This structure is just a simple
thin wrapper over the <code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span></code> string type of the C language.</p>
<p>It adds memory management facilities, so that a same string can be shared in several places without the need to
duplicate it. Also, some strings are “interned”, that is they are “persistent” allocated and specially managed by the
memory manager so that they don’t get destroyed across several requests. Those later get a permanent allocation from
<a class="reference internal" href="../../memory_management/zend_memory_manager.html"><span class="doc">Zend Memory Manager</span></a>.</p>
<div class="section" id="structure-and-access-macros">
<h2>Structure and access macros<a class="headerlink" href="#structure-and-access-macros" title="Permalink to this headline">¶</a></h2>
<p>Here is the simple <code class="docutils literal"><span class="pre">zend_string</span></code> structure exposed:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">_zend_string</span> <span class="p">{</span>
        <span class="n">zend_refcounted_h</span> <span class="n">gc</span><span class="p">;</span>
        <span class="n">zend_ulong</span>        <span class="n">h</span><span class="p">;</span>
        <span class="kt">size_t</span>            <span class="n">len</span><span class="p">;</span>
        <span class="kt">char</span>              <span class="n">val</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Like you can see, the structure embeds a <code class="docutils literal"><span class="pre">zend_refcounted_h</span></code> header. This is done for memory management and reference.
As the string is very likely to be used as the key of a HashTable probe, it embeds its hash in the <code class="docutils literal"><span class="pre">h</span></code> field. This is
an unsigned long <code class="docutils literal"><span class="pre">zend_ulong</span></code>. This number is only used when the <code class="docutils literal"><span class="pre">zend_string</span></code> needs to be hashed, especially
when used together with <a class="reference internal" href="../hashtables.html"><span class="doc">HashTables: zend_array</span></a>; this is very likely though.</p>
<p>As you know, the string knows its length as the <code class="docutils literal"><span class="pre">len</span></code> field, to support “binary strings”. Binary strings are
strings that embed one or several <code class="docutils literal"><span class="pre">NUL</span></code> characters (\0). When passed to libc functions, those strings will get
truncated or their length won’t be computed the right way. So in <code class="docutils literal"><span class="pre">zend_string</span></code>, the length of the string is always
known. Please, note that the length computes the number of ASCII chars (bytes) not counting the terminating <code class="docutils literal"><span class="pre">NUL</span></code>, but
counting the eventual middle NULs. For example, the string “foo” is stored as “foo\0” in a <code class="docutils literal"><span class="pre">zend_string</span></code> and its
length is then 3. Also, the string “foo\0bar” will be stored as “foo\0bar\0” and the length will be 7.</p>
<p>Finally, the characters are stored into the <code class="docutils literal"><span class="pre">char[1]</span></code> field. This is not a <code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span></code>, but a <code class="docutils literal"><span class="pre">char[1]</span></code>. Why that?
This is a memory optimization known as “C struct hack” (you may use a search engine with these terms). Basically, that
allows the engine to allocate space for the <code class="docutils literal"><span class="pre">zend_string</span></code> structure and the characters to be stored, as one solo C
pointer. This optimizes memory accesses as memory will be a contiguous allocated block, and not two blocks far away from each other in
memory (one for <code class="docutils literal"><span class="pre">zend_string</span> <span class="pre">*</span></code>, and one for the <code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span></code> to store into it).</p>
<p>This struct hack must be remembered, as the memory layout looks like with the C chars at the end of the C <code class="docutils literal"><span class="pre">zend_string</span></code>
structure, and may be felt/seen when using a C debugger (or when debugging strings). This hack is entirely managed by
the API you’ll use when manipulating <code class="docutils literal"><span class="pre">zend_string</span></code> structures.</p>
<img alt="../../../_images/zend_string_memory_layout.png" class="align-center" src="../../../_images/zend_string_memory_layout.png" />
</div>
<div class="section" id="using-zend-string-api">
<h2>Using zend_string API<a class="headerlink" href="#using-zend-string-api" title="Permalink to this headline">¶</a></h2>
<div class="section" id="simple-use-case">
<h3>Simple use case<a class="headerlink" href="#simple-use-case" title="Permalink to this headline">¶</a></h3>
<p>Like with <a class="reference internal" href="../zvals.html"><span class="doc">Zvals</span></a>, you don’t manipulate the <code class="docutils literal"><span class="pre">zend_string</span></code> internals fields by hand, but always use macros
for that. There also exists macros to trigger actions on strings. Those are not functions but macros, all stored into
the required <a class="reference external" href="https://github.com/php/php-src/blob/PHP-7.0/Zend/zend_string.h">Zend/zend_string.h</a> header:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">zend_string</span> <span class="o">*</span><span class="n">str</span><span class="p">;</span>

<span class="n">str</span> <span class="o">=</span> <span class="n">zend_string_init</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;This is my string: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ZSTR_VAL</span><span class="p">(</span><span class="n">str</span><span class="p">));</span>
<span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;It is %zd char long</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ZSTR_LEN</span><span class="p">(</span><span class="n">str</span><span class="p">));</span>

<span class="n">zend_string_release</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
</pre></div>
</div>
<p>The above simple example show you basic string management. The <code class="docutils literal"><span class="pre">zend_string_init()</span></code> function (which in fact is a macro,
but let’s pass such details) should be given your full C string as a <code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span></code>, and its length. The last parameter- of
type int- should be 0 or 1.
If you pass 0, you ask the engine to use a request-bound heap allocation using the Zend Memory Manager. Such allocation
will be destroyed at the end of the current request. If you don’t do it yourself, on a debug build, the engine will
shout at you about a memory leak you just created.
If you pass 1, you ask for what we called a “persistent” allocation, that is the engine will use a traditional C
<code class="docutils literal"><span class="pre">malloc()</span></code> call and will not track the memory allocation in any way.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you need more information about memory management, you may read the <a class="reference internal" href="../../memory_management.html"><span class="doc">dedicated chapter</span></a>.</p>
</div>
<p>Then, we display the string. We access the character array by using the <code class="docutils literal"><span class="pre">ZSTR_VAL()</span></code> macro. <code class="docutils literal"><span class="pre">ZSTR_LEN()</span></code> allows
access to the length information. <code class="docutils literal"><span class="pre">zend_string</span></code> related macros all start with <code class="docutils literal"><span class="pre">ZSTR_**()</span></code>, beware that is not the
same as <code class="docutils literal"><span class="pre">Z_STR**()</span></code> macros.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The length is stored using a <code class="docutils literal"><span class="pre">size_t</span></code> type. Hence, to display it, <em>“%zd”</em> is necessary for <code class="docutils literal"><span class="pre">printf()</span></code>. You
should always use the right <code class="docutils literal"><span class="pre">printf()</span></code> formats. Failing to do that can crash the application or create
security issues. For a nice recall on <code class="docutils literal"><span class="pre">printf()</span></code> formats, please visit
<a class="reference external" href="http://www.cplusplus.com/reference/cstdio/printf/">this link</a></p>
</div>
<p>Finally, we release the string using <code class="docutils literal"><span class="pre">zend_string_release()</span></code>. This release is mandatory. This is about memory management.
The “releasing” is a simple operation : decrement the reference counter of the string, if it falls to zero, the API will
free the string for you. If you forget to release a string, you will very likely create a memory leak.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">You must always think about memory management in C. If you allocate - whether directly using <code class="docutils literal"><span class="pre">malloc()</span></code>, or
using an API that will do it for you - you must <code class="docutils literal"><span class="pre">free()</span></code> at some point. Failing to do that will create memory
leaks and translate into a badly designed program that nobody will be able to use safely.</p>
</div>
</div>
<div class="section" id="playing-with-the-hash">
<h3>Playing with the hash<a class="headerlink" href="#playing-with-the-hash" title="Permalink to this headline">¶</a></h3>
<p>If you need to access the hash, use <code class="docutils literal"><span class="pre">ZSTR_H()</span></code>. However, the hash is not computed automatically when you create your
<code class="docutils literal"><span class="pre">zend_string</span></code>. It will be done for you however when using that string with the HashTable API.
If you want to force the hash to get computed now, use <code class="docutils literal"><span class="pre">ZSTR_HASH()</span></code> or <code class="docutils literal"><span class="pre">zend_string_hash_val()</span></code>.
Once the hash is computed, it is saved and never computed again. If for any reason, you need to recompute it - f.e
because you changed the value of the string - use <code class="docutils literal"><span class="pre">zend_string_forget_hash_val()</span></code>:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">zend_string</span> <span class="o">*</span><span class="n">str</span><span class="p">;</span>

<span class="n">str</span> <span class="o">=</span> <span class="n">zend_string_init</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;This is my string: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ZSTR_VAL</span><span class="p">(</span><span class="n">str</span><span class="p">));</span>
<span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;It is %zd char long</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ZSTR_LEN</span><span class="p">(</span><span class="n">str</span><span class="p">));</span>

<span class="n">zend_string_hash_val</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
<span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;The string hash is %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ZSTR_H</span><span class="p">(</span><span class="n">str</span><span class="p">));</span>

<span class="n">zend_string_forget_hash_val</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
<span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;The string hash is now cleared back to 0!&quot;</span><span class="p">);</span>

<span class="n">zend_string_release</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="string-copy-and-memory-management">
<h3>String copy and memory management<a class="headerlink" href="#string-copy-and-memory-management" title="Permalink to this headline">¶</a></h3>
<p>One very nice feature of <code class="docutils literal"><span class="pre">zend_string</span></code> API is that it allows one part to “own” a string by simply declaring interest
with it. The engine will then not duplicate the string in memory, but simply increment its refcount
(as part of its <code class="docutils literal"><span class="pre">zend_refcounted_h</span></code>). This allows sharing a single piece of memory in many places into the code.</p>
<p>That way, when we talk about “copying” a <code class="docutils literal"><span class="pre">zend_string</span></code>, in fact we don’t copy anything in memory. If needed- that is
still a possible operation- we then talk about “duplicating” the string. Here we go:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">zend_string</span> <span class="o">*</span><span class="n">foo</span><span class="p">,</span> <span class="o">*</span><span class="n">bar</span><span class="p">,</span> <span class="o">*</span><span class="n">bar2</span><span class="p">,</span> <span class="o">*</span><span class="n">baz</span><span class="p">;</span>

<span class="n">foo</span> <span class="o">=</span> <span class="n">zend_string_init</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span> <span class="cm">/* creates the &quot;foo&quot; string in foo */</span>
<span class="n">bar</span> <span class="o">=</span> <span class="n">zend_string_init</span><span class="p">(</span><span class="s">&quot;bar&quot;</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="s">&quot;bar&quot;</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span> <span class="cm">/* creates the &quot;bar&quot; string in bar */</span>

<span class="cm">/* creates bar2 and shares the &quot;bar&quot; string from bar into bar2.</span>
<span class="cm">   Also increments the refcount of the &quot;bar&quot; string to 2 */</span>
<span class="n">bar2</span> <span class="o">=</span> <span class="n">zend_string_copy</span><span class="p">(</span><span class="n">bar</span><span class="p">);</span>

<span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;We just copied two strings</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;See : bar content : %s, bar2 content : %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ZSTR_VAL</span><span class="p">(</span><span class="n">bar</span><span class="p">),</span> <span class="n">ZSTR_VAL</span><span class="p">(</span><span class="n">bar2</span><span class="p">));</span>

<span class="cm">/* Duplicate in memory the &quot;bar&quot; string, create the baz variable and</span>
<span class="cm">   make it solo owner of the newly created &quot;bar&quot; string */</span>
<span class="n">baz</span> <span class="o">=</span> <span class="n">zend_string_dup</span><span class="p">(</span><span class="n">bar</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;We just duplicated &#39;bar&#39; in &#39;baz&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;Now we are free to change &#39;baz&#39; without fearing to change &#39;bar&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="cm">/* Change the last char of the second &quot;bar&quot; string</span>
<span class="cm">   turning it to &quot;baz&quot; */</span>
<span class="n">ZSTR_VAL</span><span class="p">(</span><span class="n">baz</span><span class="p">)[</span><span class="n">ZSTR_LEN</span><span class="p">(</span><span class="n">baz</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;z&#39;</span><span class="p">;</span>

<span class="cm">/* Forget the old hash (if computed) as now the string changed, thus</span>
<span class="cm">   its hash must also change and get recomputed */</span>
<span class="n">zend_string_forget_hash_val</span><span class="p">(</span><span class="n">baz</span><span class="p">);</span>

<span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;&#39;baz&#39; content is now %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ZSTR_VAL</span><span class="p">(</span><span class="n">baz</span><span class="p">));</span>

<span class="n">zend_string_release</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span>  <span class="cm">/* destroys (frees) the &quot;foo&quot; string */</span>
<span class="n">zend_string_release</span><span class="p">(</span><span class="n">bar</span><span class="p">);</span>  <span class="cm">/* decrements the refcount of the &quot;bar&quot; string to one */</span>
<span class="n">zend_string_release</span><span class="p">(</span><span class="n">bar2</span><span class="p">);</span> <span class="cm">/* destroys (frees) the &quot;bar&quot; string both in bar and bar2 vars */</span>
<span class="n">zend_string_release</span><span class="p">(</span><span class="n">baz</span><span class="p">);</span>  <span class="cm">/* destroys (frees) the &quot;baz&quot; string */</span>
</pre></div>
</div>
<p>We start by just allocating “foo” and “bar”. Then we create the <code class="docutils literal"><span class="pre">bar2</span></code> string as being a copy of <code class="docutils literal"><span class="pre">bar</span></code>. Here, everybody
must remember : <code class="docutils literal"><span class="pre">bar</span></code> and <code class="docutils literal"><span class="pre">bar2</span></code> point to <em>the same</em> C string in memory, and changing one will change the second
one. This is <code class="docutils literal"><span class="pre">zend_string_copy()</span></code> behavior : it just increments the refcount of the owned C string.</p>
<p>If we want to separate the strings- aka we want to have two different copies of that string in memory -we need to
duplicate using <code class="docutils literal"><span class="pre">zend_string_dup()</span></code>. We then duplicate <code class="docutils literal"><span class="pre">bar2</span></code> variable string into the <code class="docutils literal"><span class="pre">baz</span></code> variable. Now, the
<code class="docutils literal"><span class="pre">baz</span></code> variable embeds its own copy of the string, and can change it without impacting <code class="docutils literal"><span class="pre">bar2</span></code>. That is what we do :
we change the final ‘r’ in ‘bar’ with a ‘z’, for ‘baz’. And then we display it, and free memory of every string.</p>
<p>Note that we forgot the hash value (if it were computed before, no need to think about that detail). This is a good
practice to remember about. Like we already said, the hash is used if the <code class="docutils literal"><span class="pre">zend_string</span></code> is used as part of HashTables.
This is a very common operation in development, and changing a string value requires to recompute the hash value as
well. Forgetting such a step will lead to bugs that could cost some time to track.</p>
</div>
<div class="section" id="string-operations">
<h3>String operations<a class="headerlink" href="#string-operations" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal"><span class="pre">zend_string</span></code> API allows other operations, such as extending or shrinking strings, changing their case or comparing
them. There is no concat operation available yet, but that is pretty easy to perform:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">zend_string</span> <span class="o">*</span><span class="n">FOO</span><span class="p">,</span> <span class="o">*</span><span class="n">bar</span><span class="p">,</span> <span class="o">*</span><span class="n">foobar</span><span class="p">,</span> <span class="o">*</span><span class="n">foo_lc</span><span class="p">;</span>

<span class="n">FOO</span> <span class="o">=</span> <span class="n">zend_string_init</span><span class="p">(</span><span class="s">&quot;FOO&quot;</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="s">&quot;FOO&quot;</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">bar</span> <span class="o">=</span> <span class="n">zend_string_init</span><span class="p">(</span><span class="s">&quot;bar&quot;</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="s">&quot;bar&quot;</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>

<span class="cm">/* Compares a zend_string against a C string literal */</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">zend_string_equals_literal</span><span class="p">(</span><span class="n">FOO</span><span class="p">,</span> <span class="s">&quot;foobar&quot;</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">foobar</span> <span class="o">=</span> <span class="n">zend_string_copy</span><span class="p">(</span><span class="n">FOO</span><span class="p">);</span>

    <span class="cm">/* realloc()ates the C string to a larger buffer */</span>
    <span class="n">foobar</span> <span class="o">=</span> <span class="n">zend_string_extend</span><span class="p">(</span><span class="n">foobar</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="s">&quot;foobar&quot;</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>

    <span class="cm">/* concatenates &quot;bar&quot; after the newly reallocated large enough &quot;FOO&quot; */</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">ZSTR_VAL</span><span class="p">(</span><span class="n">foobar</span><span class="p">)</span> <span class="o">+</span> <span class="n">ZSTR_LEN</span><span class="p">(</span><span class="n">FOO</span><span class="p">),</span> <span class="n">ZSTR_VAL</span><span class="p">(</span><span class="n">bar</span><span class="p">),</span> <span class="n">ZSTR_LEN</span><span class="p">(</span><span class="n">bar</span><span class="p">));</span>
<span class="p">}</span>

<span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;This is my new string: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ZSTR_VAL</span><span class="p">(</span><span class="n">foobar</span><span class="p">));</span>

<span class="cm">/* Compares two zend_string together */</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">zend_string_equals</span><span class="p">(</span><span class="n">FOO</span><span class="p">,</span> <span class="n">foobar</span><span class="p">))</span> <span class="p">{</span>
    <span class="cm">/* duplicates a string and lowers it */</span>
    <span class="n">foo_lc</span> <span class="o">=</span> <span class="n">zend_string_tolower</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;This is FOO in lower-case: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ZSTR_VAL</span><span class="p">(</span><span class="n">foo_lc</span><span class="p">));</span>

<span class="cm">/* frees memory */</span>
<span class="n">zend_string_release</span><span class="p">(</span><span class="n">FOO</span><span class="p">);</span>
<span class="n">zend_string_release</span><span class="p">(</span><span class="n">bar</span><span class="p">);</span>
<span class="n">zend_string_release</span><span class="p">(</span><span class="n">foobar</span><span class="p">);</span>
<span class="n">zend_string_release</span><span class="p">(</span><span class="n">foo_lc</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="zend-string-access-with-zvals">
<h3>zend_string access with zvals<a class="headerlink" href="#zend-string-access-with-zvals" title="Permalink to this headline">¶</a></h3>
<p>Now that you know how to manage and manipulate <code class="docutils literal"><span class="pre">zend_string</span></code>, let’s see the interaction they got with the <code class="docutils literal"><span class="pre">zval</span></code>
container.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">You need to be familiar with zvals, if not, read the <a class="reference internal" href="../zvals.html"><span class="doc">Zvals</span></a> dedicated chapter.</p>
</div>
<p>The macros will allow you to store a <code class="docutils literal"><span class="pre">zend_string</span></code> into a <code class="docutils literal"><span class="pre">zval</span></code>, or to read the <code class="docutils literal"><span class="pre">zend_string</span></code> from a <code class="docutils literal"><span class="pre">zval</span></code>:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">zval</span> <span class="n">myval</span><span class="p">;</span>
<span class="n">zend_string</span> <span class="o">*</span><span class="n">hello</span><span class="p">,</span> <span class="o">*</span><span class="n">world</span><span class="p">;</span>

<span class="n">zend_string_init</span><span class="p">(</span><span class="n">hello</span><span class="p">,</span> <span class="s">&quot;hello&quot;</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>

<span class="cm">/* Stores the string into the zval */</span>
<span class="n">ZVAL_STR</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myval</span><span class="p">,</span> <span class="n">hello</span><span class="p">);</span>

<span class="cm">/* Reads the C string, from the zend_string from the zval */</span>
<span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;The string is %s&quot;</span><span class="p">,</span> <span class="n">Z_STRVAL</span><span class="p">(</span><span class="n">myval</span><span class="p">));</span>

<span class="n">zend_string_init</span><span class="p">(</span><span class="n">world</span><span class="p">,</span> <span class="s">&quot;world&quot;</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="s">&quot;world&quot;</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>

<span class="cm">/* Changes the zend_string into myval : replaces it with another one */</span>
<span class="n">Z_STR</span><span class="p">(</span><span class="n">myval</span><span class="p">)</span> <span class="o">=</span> <span class="n">world</span><span class="p">;</span>

<span class="cm">/* ... */</span>
</pre></div>
</div>
<p>What you must memorize is that every macro beginning by <code class="docutils literal"><span class="pre">ZSTR_***(s)</span></code> will act on a <code class="docutils literal"><span class="pre">zend_string</span></code>.</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">ZSTR_VAL()</span></code></li>
<li><code class="docutils literal"><span class="pre">ZSTR_LEN()</span></code></li>
<li><code class="docutils literal"><span class="pre">ZSTR_HASH()</span></code></li>
<li>…</li>
</ul>
<p>Every macro beginning by <code class="docutils literal"><span class="pre">Z_STR**(z)</span></code> will act on a <code class="docutils literal"><span class="pre">zend_string</span></code> itself embedded into a <code class="docutils literal"><span class="pre">zval</span></code></p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">Z_STRVAL()</span></code></li>
<li><code class="docutils literal"><span class="pre">Z_STRLEN()</span></code></li>
<li><code class="docutils literal"><span class="pre">Z_STRHASH()</span></code></li>
<li>…</li>
</ul>
<p>A few other that you won’t probably need also exist.</p>
</div>
<div class="section" id="php-s-history-and-classical-c-strings">
<h3>PHP’s history and classical C strings<a class="headerlink" href="#php-s-history-and-classical-c-strings" title="Permalink to this headline">¶</a></h3>
<p>Just a quick note about classical C strings. In C, strings are character arrays (<code class="docutils literal"><span class="pre">char</span> <span class="pre">foo[]</span></code>), or pointers to
characters (<code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span></code>). They don’t know anything about their length, that’s why they are NULL terminated (knowing the
beginning of the string and its end, you know its length).</p>
<p>Before PHP 7, <code class="docutils literal"><span class="pre">zend_string</span></code> structure simply did not exist. A traditional <code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">/</span> <span class="pre">int</span></code> couple were used back in
that time. You may still find rare places into PHP source where <code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">/</span> <span class="pre">int</span></code> couple is used instead of
<code class="docutils literal"><span class="pre">zend_string</span></code>. You may also find API facilities to interact between a <code class="docutils literal"><span class="pre">zend_string</span></code> on one side, and a
<code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">/</span> <span class="pre">int</span></code> couple on the other side.</p>
<p>Wherever it is possible : make use of <code class="docutils literal"><span class="pre">zend_string</span></code>. Some rare places don’t make use of <code class="docutils literal"><span class="pre">zend_string</span></code> because it
is not relevant at that place to use them, but you’ll find lots of reference to <code class="docutils literal"><span class="pre">zend_string</span></code> anyway in PHP source
code.</p>
</div>
<div class="section" id="interned-zend-string">
<h3>Interned zend_string<a class="headerlink" href="#interned-zend-string" title="Permalink to this headline">¶</a></h3>
<p>Just a quick word here about <a class="reference external" href="https://en.wikipedia.org/wiki/String_interning">interned strings</a>. You could
need such a concept in extension development. Interned strings also interact with OPCache extension.</p>
<p>Interned strings are deduplicated strings. When used with OPCache, they also get reused from request to request.</p>
<p>Say you want to create the string “foo”. What you tend to do is simply create a new string “foo”:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">zend_string</span> <span class="o">*</span><span class="n">foo</span><span class="p">;</span>
<span class="n">foo</span> <span class="o">=</span> <span class="n">zend_string_init</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>

<span class="cm">/* ... */</span>
</pre></div>
</div>
<p>But a question arises : Hasn’t that piece of string already been created before you need it?
When you need a string, you code is executed at some point in PHP’s life, that means that some piece of code happening
before yours may have needed the exact same piece of string (“foo” for our example).</p>
<p>Interned strings is about asking the engine to probe the interned strings store, and reuse the already allocated pointer
if it could find your string. If not : create a new string and “intern” it, that is make it available to other parts
of PHP source code (other extensions, the engine itself, etc…).</p>
<p>Here is an example:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">zend_string</span> <span class="o">*</span><span class="n">foo</span><span class="p">;</span>
<span class="n">foo</span> <span class="o">=</span> <span class="n">zend_string_init</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>

<span class="n">foo</span> <span class="o">=</span> <span class="n">zend_new_interned_string</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span>

<span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;This string is interned : %s&quot;</span><span class="p">,</span> <span class="n">ZSTR_VAL</span><span class="p">(</span><span class="n">foo</span><span class="p">));</span>

<span class="n">zend_string_release</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span>
</pre></div>
</div>
<p>What we do in the code above, is we create a new <code class="docutils literal"><span class="pre">zend_string</span></code> very classically. Then, we pass that created
<code class="docutils literal"><span class="pre">zend_string</span></code> to <code class="docutils literal"><span class="pre">zend_new_interned_string()</span></code>. This function looks for the same piece of string (“foo” here) into
the engine interned string buffer. If it finds it (meaning someone already created such a string), it then releases
your string (probably freeing it) and replaces it with the string from the interned string buffer. If it does not find it:
it adds it to the interned string buffer and so makes it available for future usage or other parts of PHP.</p>
<p>You must take care about memory allocation. Interned strings always have a refcount set to one, because they don’t need
to be refcounted, as they will get shared with the interned strings buffer, and thus they can’t be destroyed out of it.</p>
<p>Example:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">zend_string</span> <span class="o">*</span><span class="n">foo</span><span class="p">,</span> <span class="o">*</span><span class="n">foo2</span><span class="p">;</span>

<span class="n">foo</span>  <span class="o">=</span> <span class="n">zend_string_init</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">foo2</span> <span class="o">=</span> <span class="n">zend_string_copy</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span> <span class="cm">/* increments refcount of foo */</span>

 <span class="cm">/* refcount falls back to 1, even if the string is now</span>
<span class="cm">  * used at three different places */</span>
<span class="n">foo</span> <span class="o">=</span> <span class="n">zend_new_interned_string</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span>

<span class="cm">/* This doesn&#39;t do anything, as foo is interned */</span>
<span class="n">zend_string_release</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span>

<span class="cm">/* This doesn&#39;t do anything, as foo2 is interned */</span>
<span class="n">zend_string_release</span><span class="p">(</span><span class="n">foo2</span><span class="p">);</span>

<span class="cm">/* At the end of the process, PHP will purge its interned</span>
<span class="cm">  string buffer, and thus free() our &quot;foo&quot; string itself */</span>
</pre></div>
</div>
<p>It’s all about garbage collection.</p>
<p>When a string is interned, its GC flags are changed to add the <code class="docutils literal"><span class="pre">IS_STR_INTERNED</span></code> flag, whatever the memory allocation
class they use (permanent or request based).
This flag is probed when you want to copy or release a string. If the string is interned, the engine does not increment
its refcount as you copy the string. But it doesn’t decrement it nor free it if you release the string. It shadowly
does nothing. At the end of the process lifetime, it will destroy its interned strings buffer, and it will free your
interned strings.</p>
<p>This process is in fact a little bit more complex than this. If you make use of an interned string out of a
<a class="reference internal" href="../../extensions_design/php_lifecycle.html"><span class="doc">request processing</span></a>, that string will be interned for sure.
However, if you make use of an interned string as PHP is treating a request, then this string will only get interned for
the current request, and will get cleared after that.
All this is valid if you don’t use the OPCache extension, something you shouldn’t do : use it.</p>
<p>When using the OPCache extension, if you make use of an interned string out of a
<a class="reference internal" href="../../extensions_design/php_lifecycle.html"><span class="doc">request processing</span></a>, that string will be
interned for sure and will also be shared to every PHP process or thread that will be spawned by you parallelism layer.
Also, if you make use of an interned string as PHP is treating a request, this string will also get interned by OPCache
itself, and shared to every PHP process or thread that will be spawned by you parallelism layer.</p>
<p>Interned strings mechanisms are then changed when OPCache extension fires in. OPCache not only allows to intern strings
that come from a request, but it also allows to share them to every PHP process of the same pool. This is done using
shared memory. When saving an interned string, OPCache will also add the <code class="docutils literal"><span class="pre">IS_STR_PERMANENT</span></code> flag to its GC info.
That flag means the memory allocation used for the structure (<code class="docutils literal"><span class="pre">zend_string</span></code> here) is permanent, it could be a shared
read-only memory segment.</p>
<p>Interned strings save memory, because the same string is never stored more than once in memory. But it could waste some
CPU time as it often needs to lookup the interned strings store, even if that process is well optimized yet.
As an extension designer, here are global rules:</p>
<ul class="simple">
<li>If OPCache is used (it should be), and if you need to create read-only strings : use an interned string.</li>
<li>If you need a string you know for sure PHP will have interned (a well-known-PHP-string, f.e “php” or “str_replace”),
use an interned string.</li>
<li>If the string is not read-only and could/should be altered after its been created, do not use an interned string.</li>
<li>If the string is unlikely to be reused in the future, do not use an interned string.</li>
</ul>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Never ever try to modify (write to) an interned string, you’ll likely crash.</p>
</div>
<p>Interned strings are detailed in <a class="reference external" href="https://github.com/php/php-src/blob/PHP-7.0/Zend/zend_string.c">Zend/zend_string.c</a></p>
</div>
</div>
</div>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="../strings.html">Strings management</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../../../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="smart_str.html">smart_str API</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer feedback">
        The repository for this book is available on <a href="https://github.com/phpinternalsbook/PHP-Internals-Book">GitHub</a>.
        <br/><br/>
        <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">
            <img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" />
        </a>
        <br />
        The PHP internals book is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.
    </div>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-41617167-1', 'phpinternalsbook.com');
      ga('send', 'pageview');
    </script>

  </body>
</html>